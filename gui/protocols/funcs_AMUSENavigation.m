function cell_out = funcs_AMUSENavigation(fnc, handles, varargin),

%%% The required behavior of any protocol file for when it's called with no
%%% argument is that it exposes the functions that it implements.
%%% When a subfunction is added, make it visible by adding it's name here.
if nargin == 0,
    cell_out = {'online_settings', ...
        'calibration_settings', ...
        'experiment_settings', ...
        'run_experiments', ...
        'stop_experiments'};
    return;
end

%%% Start of part that should be left untouched.
fh = str2func(fnc);
[cell_out{1:nargout(fh)}] = fh(varargin{:});
if ~islogical(cell_out{1}),
    error('first output parameter of each subfunction must be bool');
end
%%% End of part that should be left untouched.

end

%%% Here you can add your own functions. They can overwrite those in
%%% default (fill_defaults is false), or extend them (fill_defaults is
%%% true). Any function added will only be visible if it's name is added
%%% above.
function [fill_defaults, bbci] = online_settings(varargin),
if strcmp(varargin{1}, 'variables'),
    fill_defaults = false;
    bbci = {};
    return
elseif ~isempty(varargin{1}),
    bbci = varargin{1};
end
bbci.source.acquire_fcn = @bbci_acquire_bv;
bbci.source.acquire_param = {struct('fs', 100)};
bbci.log.output = 'file';
bbci.log.classifier = 1;
bbci.control.fcn = @bbci_control_ERP_navigation;
bbci.control.param = struct('window', [.25 .5 .75 1], ...
    'bufferSize', 4, ...
    'nClasses', 7, ...
    'mapping', [1 1 0 -1 -1 0 0; 0 1 1 1 0 0 0 ; 0 0 0 0 0 1 -1], ...
    'update_ival', 1);
bbci.feedback.receiver = 'osc';
bbci.feedback.host = '127.0.0.1';
bbci.feedback.port = 6350;
bbci.quit_condition.marker = 254;
bbci.adaptation.active= 0;
bbci.adaptation.fcn= @bbci_adaptation_pcov_ERP;
bbci.adaptation.load_classifier= 0; % no need to load classifier
opt_adapt = [];
opt_adapt.alpha = 0.05;
opt_adapt.mrk_end_of_segment = 2;
opt_adapt.min_n_data_points = 100;
opt_adapt.mrk_stimuli = [20:32]; 
bbci.adaptation.param= {opt_adapt};
fill_defaults = false;
end

function [fill_defaults, bbci] = calibration_settings(varargin),
if ~isempty(varargin{1}) && strcmp(varargin{1}, 'variables'),
    fill_defaults = false;
    bbci = {};
    return
elseif ~isempty(varargin{1}),
    bbci = varargin{1};
end

global BBCI;

% get preset intervals
ivals = [80,350; 360, 800];
deltas = [20, 60];
opt.cfy_ival = [];
for k=1:size(ivals,1)
    t_lims = ivals(k,:);
    dt = deltas(k);
    sampling_points = t_lims(1):dt:t_lims(2);
    tmp_ivals = round([sampling_points' - dt/2, sampling_points' + dt/2]);
    opt.cfy_ival = [opt.cfy_ival; tmp_ivals];
end

bbci.calibrate.folder = BBCI.Tp.Dir;
bbci.calibrate.file =  'SETBYGUI';
bbci.calibrate.read_fcn = @file_readBV;
bbci.calibrate.read_param = {'fs', 100};
bbci.calibrate.marker_fcn = @mrk_defineClasses;
bbci.calibrate.marker_param = {{[120:132], [20:32]; 'Target', 'Non-target'}};
bbci.calibrate.save.file = 'bbci_classifier';
bbci.calibrate.save.overwrite = 0;
bbci.calibrate.fcn = @bbci_calibrate_ERP_navigation;
bbci.calibrate.settings = opt_proplistToStruct(...
    'disp_ival', [-150 1000], ...
    'ref_ival', [-150 0], ... % be aware that if this is turned off, a bandpass filter should be set
    'band', 40, ... 
    'cfy_clab', {'not','E*','Fp*','AF*','A*'}, ...
    'cfy_ival', opt.cfy_ival, ...
    'control_per_stimulus', 1, ...
    'model', {'train_RLDAshrink', 'store_means', 1, 'store_cov', 1}, ...
    'nSequences', [], ...
    'nClasses', [], ...
    'cue_markers', [20:32], ...
    'create_figs', 0);
%bbci.calibrate.early_stopping_fnc = @bbci_train_rankdiff;
%bbci.calibrate.early_stopping_param = {'indices', {[1:6], [7:12];'rows', 'columns'}, ...
%    'nClasses', 12, ...
%    'nIters', 12};
%bbci.calibrate.save.figure = 1;
fill_defaults = false;
end

function [fill_defaults, experiments] = experiment_settings(varargin),
%%% This function is potentially very verbose, as it defines all the
%%% parameters for the different experiments.
if strcmp(varargin{1}, 'variables'),
    fill_defaults = false;
    experiments = {};
    return
end

global BBCI DROPBOX GTEC_SERIAL

BBCI.Tp.Geometry = [1280, 0, 1024, 768];

experiments.classifier_name = {'bbci_classifier'};
experiments.allowed_files = {'navigation_train_'};
experiments.experiment_names = {...
    'Rest state EEG', ...
    'Artifact measurement', ...
    'Short rest state EEG', ...
    'Calibration standard', ...
    'Calibration continuous', ...
    'Online house setting', ...
    'Online park setting'};
experiments.requires_online = [0 0 0 0 0 1 1];
experiments.requires_adaptation = [0 0 0 0 0 0 0];
experiments.requires_stopping = [0 0 0 0 0 0 0];
experiments.editable_params = {
    {}, ...
    {}, ...
    {}, ...
    {}, ...
    {}, ...
    {}, ...
    {}, ...
    };

soundset = opt_proplistToStruct( ...
    'type',             'tone+noise', ...
    'samplingfs',       44100, ...
    'tonefs',           440, ...
    'tonesteps',        3, ...
    'noisefs',          [3000 7500], ...
    'noisesteps',       [30 30], ...
    'duration',         40);

soundcard = opt_proplistToStruct( ...
    'driver',           'MME', ...
    'inputChannels',    2, ...
    'outputChannels',   2, ...
    'mode',             1, ...
    'fs',               44100);

amuse = opt_proplistToStruct( ...
    'mode',             'free', ...
    'itType',           'continuous', ...
    'decisionType',     'none', ...
    'spellString',      '', ...
    'application',      'CONT_navi', ...
    'minRounds',        3, ...
    'maxRounds',        10, ...
    'dataPort',         12345, ...
    'speakerSelected',  [1:2], ...
    'speakerCount',     2, ...
    'bv_host',          '127.0.0.1', ...
    'recorderControl',  0, ...
    'doLog',            1, ...
    'test',             1, ...
    'useSpeech',        0, ...
    'soundset',         soundset, ...
    'soundcard',        soundcard, ...
    'calibrated',       [.1 0; 0 .1]);
    
    

% set the final experiment parameters
ex.pa.(genvarname('Rest state EEG')) = opt_proplistToStruct(...
    'filename', 'RestState', ...
    'n_blocks', 1, ...
    'eyes_open_time', 60000, ...
    'eyes_closed_time', 60000);
ex.pa.(genvarname('Short rest state EEG')) = ...
    opt_proplistToStruct(ex.pa.(genvarname('Rest state EEG')), ...
    'filename', 'RestStateShort', ...
    'n_blocks', 1);
ex.pa.(genvarname('Artifact measurement')) = opt_proplistToStruct(...
    'filename', 'Artifacts', ...
    'n_blocks', 6, ...
    'time_for_movement', 4500, ...
    'pause_after_n_blocks', 3, ...
    'pause_time', 10000, ...
    'directions', {'F8', 'F9', 'F10', 'F11'});
ex.pa.(genvarname('Calibration standard')) = ...
    opt_proplistToStruct(amuse, ...
    'mode', 'copy', ...
    'itType', 'fixed', ...
    'filename', 'navigation_train_std_', ...
    'maxRounds', 15, ...
    'application', 'TRAIN');
ex.pa.(genvarname('Calibration continuous')) = ...
    opt_proplistToStruct(amuse, ...
    'mode', 'copy', ...
    'itType', 'fixed', ...
    'filename', 'navigation_train_cont_', ...
    'maxRounds', 15, ...
    'application', 'TRAIN');
ex.pa.(genvarname('Online house setting')) = ...
    opt_proplistToStruct(amuse, ...
    'filename', 'navigation_online_house_', ...
    'mode', 'free');
ex.pa.(genvarname('Online park setting')) = ...
    opt_proplistToStruct(amuse, ...
    'filename', 'navigation_online_park_', ...
    'mode', 'free');

experiments.parameters = ex.pa;
fill_defaults = false;
end

function [fill_defaults, output] = run_experiments(varargin),
%%% This function is potentially very verbose, as it defines all the
%%% parameters for the different experiments.
if strcmp(varargin{1}, 'variables'),
    fill_defaults = false;
    output = {};
    return
end

global BBCI
output = [];
fill_defaults = false;
experiment = varargin{1}.experiment;
ES = varargin{1}.parameters;
bbci = varargin{1}.bbci;
ES.use_signal_server = strcmp(func2str(bbci.source.acquire_fcn), 'bbci_acquire_sigserv');

switch experiment,
    case genvarname({'Rest state EEG', 'Short rest state EEG'})
        seq = ['P2000 f21P2000 ' ...
            sprintf('R[%d](F15P%d F14P%d) ', ES.n_blocks, ES.eyes_open_time, ES.eyes_closed_time)...
            'F20P1000'];
        [seq, wav, opt]= setup_artifacts_and_resting_measurement('language', 'deutsch', ...
            'seq', seq, 'show_description', 0);
        opt.test = 1;        
        stim_artifactMeasurement(seq, wav, opt);
    case genvarname('Artifact measurement'),
        seq = sprintf('P2000 F15P3000 f6f7P%d', ES.time_for_movement);
        n_directions = length(ES.directions);
        for b=1:ES.n_blocks
            idx = randperm(n_directions);
            for k=1:n_directions
                seq = sprintf('%s%sP%d ', seq, ES.directions{idx(k)}, ES.time_for_movement);
                seq = sprintf('%sF7P%d ', seq, ES.time_for_movement);
            end
            if ES.pause_after_n_blocks && mod(b, ES.pause_after_n_blocks)==0 && b<ES.n_blocks
                seq = sprintf('%sf21P%d f6f7P%d', seq, ES.pause_time, ES.time_for_movement);
            end
        end
        seq = sprintf('%sP2000 F20P1000', seq);
        [seq, wav, opt]= setup_artifacts_and_resting_measurement('language', 'italian', ...
            'seq', seq, 'show_description', 0);
        opt.test = 1;
        stim_artifactMeasurement(seq, wav, opt);
    otherwise, %let's start with AMUSE
       opt = ES; % application expects this terminology
       setfil = [BBCI.Tp.Dir 'amuse_settings.mat'];
       save(setfil, 'opt');
       system(['matlab -nosplash -r "dbstop if error; BBCI.Tp.Dir=''' BBCI.Tp.Dir ''';' ...
           'auditory_MainRoutine(''' setfil ''');" &']);
       
end
end

function [fill_defaults, output] = stop_experiments(varargin),
    ppTrigger(varargin{1}.bbci.quit_condition.marker);
    bvr_sendcommand('stoprecording');
    % do something
end
